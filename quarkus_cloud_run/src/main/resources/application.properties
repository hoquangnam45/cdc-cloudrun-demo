# Application Name
quarkus.application.name=quarkus-cloud-run

# Datasource Configuration
quarkus.datasource.db-kind=postgresql
quarkus.datasource.username=${DB_USER}
quarkus.datasource.password=${DB_PASS}

# JDBC URL for Google Cloud SQL
quarkus.datasource.jdbc.url=jdbc:postgresql:///${DB_NAME}
quarkus.datasource.jdbc.additional-jdbc-properties.socketFactory=com.google.cloud.sql.postgres.SocketFactory
quarkus.datasource.jdbc.additional-jdbc-properties.cloudSqlInstance=${INSTANCE_CONNECTION_NAME}

# Connection Pool Settings
quarkus.datasource.jdbc.max-size=5
quarkus.datasource.jdbc.min-size=0

# Hibernate ORM Configuration
quarkus.hibernate-orm.database.generation=update
quarkus.hibernate-orm.log.sql=false

# Health Check - Configure SmallRye Health
quarkus.smallrye-health.ui.root-path=/actuator/health
quarkus.http.non-application-root-path=/actuator
# This makes health available at /actuator/health/live, /actuator/health/ready, /actuator/health

# Disable tests
quarkus.test.continuous-testing=disabled

# Native Image Configuration - Fix JNR-FFI and Unix Socket issues
# Initialize the entire jnr stack at runtime to avoid thread/cleaner initialization during build
quarkus.native.additional-build-args=--initialize-at-run-time=jnr,\
--initialize-at-run-time=com.kenai.jffi

# Container Image Configuration (Jib)
quarkus.container-image.builder=jib
quarkus.container-image.registry=asia-southeast1-docker.pkg.dev
quarkus.container-image.group=${GCP_PROJECT_ID}/cloud-run-demo
quarkus.container-image.name=quarkus-cloud-run
quarkus.container-image.tag=latest

# JVM Base Image
quarkus.jib.base-jvm-image=registry.access.redhat.com/ubi9/openjdk-21-runtime:1.21

# Native Base Image  
quarkus.jib.base-native-image=registry.access.redhat.com/ubi9/ubi-minimal:9.5

# Jib Configuration
quarkus.jib.platforms=linux/amd64
